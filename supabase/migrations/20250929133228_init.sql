create table "public"."games" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "name" text,
    "description" text,
    "min_players" bigint,
    "max_players" bigint,
    "updated_at" timestamp without time zone,
    "image" text,
    "thumbnail" text,
    "designer" text,
    "playing_time" bigint,
    "year_published" bigint,
    "min_playtime" bigint,
    "max_playtime" bigint,
    "age" bigint,
    "bgg_rating" double precision,
    "bgg_weight" double precision,
    "bgg_rank" bigint
);


create table "public"."matches" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "name" text,
    "game_id" bigint,
    "description" text,
    "startAt" date,
    "endAt" date,
    "min_players" bigint,
    "max_players" bigint,
    "winner_id" bigint
);


create table "public"."profiles" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "user_id" uuid not null default gen_random_uuid(),
    "firstname" text,
    "lastname" text,
    "birthday" date not null,
    "country" text,
    "username" text,
    "image" text
);


create table "public"."profiles_matches" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "profile_id" bigint,
    "match_id" bigint,
    "points" double precision
);


create table "public"."roles" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "name" text default ''::text
);


create table "public"."score_sheets" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "game_id" bigint,
    "configuration" json
);


create table "public"."users_roles" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "user_id" uuid default gen_random_uuid(),
    "role_id" bigint
);


CREATE UNIQUE INDEX games_pkey ON public.games USING btree (id);

CREATE UNIQUE INDEX profiles_matches_pkey ON public.profiles_matches USING btree (id);

CREATE UNIQUE INDEX profiles_matches_profile_id_match_id_key ON public.profiles_matches USING btree (profile_id, match_id);

CREATE UNIQUE INDEX profiles_pkey ON public.profiles USING btree (id);

CREATE UNIQUE INDEX profiles_user_id_key ON public.profiles USING btree (user_id);

CREATE UNIQUE INDEX roles_pkey ON public.roles USING btree (id);

CREATE UNIQUE INDEX score_sheets_pkey ON public.score_sheets USING btree (id);

CREATE UNIQUE INDEX tournaments_pkey ON public.matches USING btree (id);

CREATE UNIQUE INDEX users_roles_pkey ON public.users_roles USING btree (id);

alter table "public"."games" add constraint "games_pkey" PRIMARY KEY using index "games_pkey";

alter table "public"."matches" add constraint "tournaments_pkey" PRIMARY KEY using index "tournaments_pkey";

alter table "public"."profiles" add constraint "profiles_pkey" PRIMARY KEY using index "profiles_pkey";

alter table "public"."profiles_matches" add constraint "profiles_matches_pkey" PRIMARY KEY using index "profiles_matches_pkey";

alter table "public"."roles" add constraint "roles_pkey" PRIMARY KEY using index "roles_pkey";

alter table "public"."score_sheets" add constraint "score_sheets_pkey" PRIMARY KEY using index "score_sheets_pkey";

alter table "public"."users_roles" add constraint "users_roles_pkey" PRIMARY KEY using index "users_roles_pkey";

alter table "public"."matches" add constraint "matches_winner_id_fkey" FOREIGN KEY (winner_id) REFERENCES profiles(id) ON DELETE SET NULL not valid;

alter table "public"."matches" validate constraint "matches_winner_id_fkey";

alter table "public"."matches" add constraint "tournaments_game_id_fkey" FOREIGN KEY (game_id) REFERENCES games(id) ON UPDATE RESTRICT ON DELETE RESTRICT not valid;

alter table "public"."matches" validate constraint "tournaments_game_id_fkey";

alter table "public"."profiles" add constraint "profiles_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."profiles" validate constraint "profiles_user_id_fkey";

alter table "public"."profiles" add constraint "profiles_user_id_key" UNIQUE using index "profiles_user_id_key";

alter table "public"."profiles_matches" add constraint "profiles_matches_match_id_fkey" FOREIGN KEY (match_id) REFERENCES matches(id) ON UPDATE RESTRICT ON DELETE RESTRICT not valid;

alter table "public"."profiles_matches" validate constraint "profiles_matches_match_id_fkey";

alter table "public"."profiles_matches" add constraint "profiles_matches_profile_id_fkey" FOREIGN KEY (profile_id) REFERENCES profiles(id) ON UPDATE RESTRICT ON DELETE RESTRICT not valid;

alter table "public"."profiles_matches" validate constraint "profiles_matches_profile_id_fkey";

alter table "public"."profiles_matches" add constraint "profiles_matches_profile_id_match_id_key" UNIQUE using index "profiles_matches_profile_id_match_id_key";

alter table "public"."score_sheets" add constraint "score_sheets_game_id_fkey" FOREIGN KEY (game_id) REFERENCES games(id) ON DELETE SET NULL not valid;

alter table "public"."score_sheets" validate constraint "score_sheets_game_id_fkey";

alter table "public"."users_roles" add constraint "users_roles_role_id_fkey" FOREIGN KEY (role_id) REFERENCES roles(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."users_roles" validate constraint "users_roles_role_id_fkey";

alter table "public"."users_roles" add constraint "users_roles_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."users_roles" validate constraint "users_roles_user_id_fkey";

create policy "Enable read access for all users to matches"
on "public"."matches"
as permissive
for select
to public
using (true);


create policy "Allow a user to create their own profile."
on "public"."profiles"
as permissive
for insert
to public
with check ((auth.uid() = user_id));


create policy "Allow a user to read their own profile."
on "public"."profiles"
as permissive
for select
to public
using ((auth.uid() = user_id));



